<span class='diff'>&lt;?php<br>/**<br> * Option API<br> *<br> * @package WordPress<br> * @subpackage Option<br> */<br><br>/**<br> * Retrieves an option value based on an option name.<br> *<br> * If the option does not exist, and a default value is not provided,<br> * boolean false is returned. This could be used to check whether you need<br> * to initialize an option during installation of a plugin, however that<br> * can be done better by using add_option() which will not overwrite<br> * existing options.<br> *<br> * Not initializing an option and using boolean `false` as a return value<br> * is a bad practice as it triggers an additional database query.<br> *<br> * The type of the returned value can be different from the type that was passed<br> * when saving or updating the option. If the option value was serialized,<br> * then it will be unserialized when it is returned. In this case the type will<br> * be the same. For example, storing a non-scalar value like an array will<br> * return the same array.<br> *<br> * In most cases non-string scalar and null values will be converted and returned<br> * as string equivalents.<br> *<br> * Exceptions:<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'><br> *</ins><span class='diff'> 1. When the option has not been saved in the database, the `$default` value<br> *    is returned if provided. If not, boolean `false` is returned.<br> * 2. When one of the Options API filters is used: {@see &#39;pre_option_</span><del class='diff-delete diff' style='background: #ffe6e6'>{</del><span class='diff'>$option</span><del class='diff-delete diff' style='background: #ffe6e6'>}</del><span class='diff'>&#39;},<br> *    {@see &#39;default_option_</span><del class='diff-delete diff' style='background: #ffe6e6'>{</del><span class='diff'>$option</span><del class='diff-delete diff' style='background: #ffe6e6'>}</del><span class='diff'>&#39;}, or {@see &#39;option_</span><del class='diff-delete diff' style='background: #ffe6e6'>{</del><span class='diff'>$option</span><del class='diff-delete diff' style='background: #ffe6e6'>}</del><span class='diff'>&#39;}, the returned<br> *    value may not match the expected type.<br> * 3. When the option has just been saved in the database, and get_option()<br> *    is used right after, non-string scalar and null values are not converted to<br> *    string equivalents and the original type is returned.<br> *<br> * Examples:<br> *<br> * When adding options like this: `add_option( &#39;my_option_name&#39;, &#39;value&#39; )</span><del class='diff-delete diff' style='background: #ffe6e6'>;</del><span class='diff'>`<br> * and then retrieving them with `get_option( &#39;my_option_name&#39; )</span><del class='diff-delete diff' style='background: #ffe6e6'>;</del><span class='diff'>`, the returned<br> * values will be:<br> *<br> * </span><ins class='diff-insert diff' style='background: #e6ffe6;'>  - </ins><span class='diff'>`false` returns `string(0) &#34;&#34;`<br> * </span><ins class='diff-insert diff' style='background: #e6ffe6;'>  - </ins><span class='diff'>`true`  returns `string(1) &#34;1&#34;`<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'>   -</ins><span class='diff'> `0`     returns `string(1) &#34;0&#34;`<br> * </span><ins class='diff-insert diff' style='background: #e6ffe6;'>  - </ins><span class='diff'>`1`     returns `string(1) &#34;1&#34;`<br> * </span><ins class='diff-insert diff' style='background: #e6ffe6;'>  - </ins><span class='diff'>`&#39;0&#39;`   returns `string(1) &#34;0&#34;`<br> * </span><ins class='diff-insert diff' style='background: #e6ffe6;'>  - </ins><span class='diff'>`&#39;1&#39;`   returns `string(1) &#34;1&#34;`<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'>   -</ins><span class='diff'> `null`  returns `string(0) &#34;&#34;`<br> *<br> * When adding options with non-scalar values like<br> * `add_option( &#39;my_array&#39;, array( false, &#39;str&#39;, null ) )</span><del class='diff-delete diff' style='background: #ffe6e6'>;</del><span class='diff'>`, the returned value<br> * will be identical to the original as it is serialized before saving<br> * it in the database:<br> *<br> *    </span><ins class='diff-insert diff' style='background: #e6ffe6;'> </ins><span class='diff'>array(3) {<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'> </ins><span class='diff'>        [0] =&gt; bool(false)<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'> </ins><span class='diff'>        [1] =&gt; string(3) &#34;str&#34;<br> *        </span><ins class='diff-insert diff' style='background: #e6ffe6;'> </ins><span class='diff'>[2] =&gt; NULL<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'> </ins><span class='diff'>    }<br> *<br> * @since 1.5.0<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param string $option  Name of the option to retrieve. Expected to not be SQL-escaped.<br> * @param mixed  $default Optional. Default value to return if the option does not exist.<br> * @return mixed Value of the option. A value of any type may be returned, including<br> *               scalar (string, boolean, float, integer), null, array, object.<br> *               Scalar and null values will be returned as strings as long as they originate<br> *               from a database stored option value. If there is no option in the database,<br> *               boolean `false` is returned.<br> */<br>function get_option( $option, $default = false ) {<br>	global $wpdb;<br><br>	if ( is_scalar( $option ) ) {<br>		$option = trim( $option );<br>	}<br><br>	if ( empty( $option ) ) {<br>		return false;<br>	}<br><br>	/*<br>	 * Until a proper _deprecated_option() function can be introduced,<br>	 * redirect requests to deprecated keys to the new, correct ones.<br>	 */<br>	$deprecated_keys = array(<br>		&#39;blacklist_keys&#39;    =&gt; &#39;disallowed_keys&#39;,<br>		&#39;comment_whitelist&#39; =&gt; &#39;comment_previously_approved&#39;,<br>	);<br><br>	if ( ! wp_installing() &amp;&amp; isset( $deprecated_keys[ $option ] ) ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;5.5.0&#39;,<br>			sprintf(<br>				/* translators: 1: Deprecated option key, 2: New option key. */<br>				__( &#39;The &#34;%1$s&#34; option key has been renamed to &#34;%2$s&#34;.&#39; ),<br>				$option,<br>				$deprecated_keys[ $option ]<br>			)<br>		);<br>		return get_option( $deprecated_keys[ $option ], $default );<br>	}<br><br>	/**<br>	 * Filters the value of an existing option before it is retrieved.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * Returning a truthy value from the filter will effectively short-circuit retrieval<br>	 * and return the passed value instead.<br>	 *<br>	 * @since 1.5.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.9.0 The `$default` parameter was added.<br>	 *<br>	 * @param mixed  $pre_option The value to return instead of the option value. This differs<br>	 *                           from `$default`, which is used as the fallback value in the event<br>	 *                           the option doesn&#39;t exist elsewhere in get_option().<br>	 *                           Default false (to skip past the short-circuit).<br>	 * @param string $option     Option name.<br>	 * @param mixed  $default    The fallback value to return if the option does not exist.<br>	 *                           Default false.<br>	 */<br>	$pre = apply_filters( &#34;pre_option_{$option}&#34;, false, $option, $default );<br><br>	if ( false !== $pre ) {<br>		return $pre;<br>	}<br><br>	if ( defined( &#39;WP_SETUP_CONFIG&#39; ) ) {<br>		return false;<br>	}<br><br>	// Distinguish between `false` as a default, and not passing one.<br>	$passed_default = func_num_args() &gt; 1;<br><br>	if ( ! wp_installing() ) {<br>		// Prevent non-existent options from triggering multiple queries.<br>		$notoptions = wp_cache_get( &#39;notoptions&#39;, &#39;options&#39; );<br><br>		if ( isset( $notoptions[ $option ] ) ) {<br>			/**<br>			 * Filters the default value for an option.<br>			 *<br>			 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>			 *<br>			 * @since 3.4.0<br>			 * @since 4.4.0 The `$option` parameter was added.<br>			 * @since 4.7.0 The `$passed_default` parameter was added to distinguish between a `false` value and the default parameter value.<br>			 *<br>			 * @param mixed  $default The default value to return if the option does not exist<br>			 *                        in the database.<br>			 * @param string $option  Option name.<br>			 * @param bool   $passed_default Was `get_option()` passed a default value?<br>			 */<br>			return apply_filters( &#34;default_option_{$option}&#34;, $default, $option, $passed_default );<br>		}<br><br>		$alloptions = wp_load_alloptions();<br><br>		if ( isset( $alloptions[ $option ] ) ) {<br>			$value = $alloptions[ $option ];<br>		} else {<br>			$value = wp_cache_get( $option, &#39;options&#39; );<br><br>			if ( false === $value ) {<br>				$row = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &#34;SELECT option_value FROM $wpdb-&gt;options WHERE option_name = %s LIMIT 1&#34;, $option ) );<br><br>				// Has to be get_row() instead of get_var() because of funkiness with 0, false, null values.<br>				if ( is_object( $row ) ) {<br>					$value = $row-&gt;option_value;<br>					wp_cache_add( $option, $value, &#39;options&#39; );<br>				} else { // Option does not exist, so we must cache its non-existence.<br>					if ( ! is_array( $notoptions ) ) {<br>						$notoptions = array();<br>					}<br><br>					$notoptions[ $option ] = true;<br>					wp_cache_set( &#39;notoptions&#39;, $notoptions, &#39;options&#39; );<br><br>					/** This filter is documented in wp-includes/option.php */<br>					return apply_filters( &#34;default_option_{$option}&#34;, $default, $option, $passed_default );<br>				}<br>			}<br>		}<br>	} else {<br>		$suppress = $wpdb-&gt;suppress_errors();<br>		$row      = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &#34;SELECT option_value FROM $wpdb-&gt;options WHERE option_name = %s LIMIT 1&#34;, $option ) );<br>		$wpdb-&gt;suppress_errors( $suppress );<br><br>		if ( is_object( $row ) ) {<br>			$value = $row-&gt;option_value;<br>		} else {<br>			/** This filter is documented in wp-includes/option.php */<br>			return apply_filters( &#34;default_option_{$option}&#34;, $default, $option, $passed_default );<br>		}<br>	}<br><br>	// If home is not set, use siteurl.<br>	if ( &#39;home&#39; === $option &amp;&amp; &#39;&#39; === $value ) {<br>		return get_option( &#39;siteurl&#39; );<br>	}<br><br>	if ( in_array( $option, array( &#39;siteurl&#39;, &#39;home&#39;, &#39;category_base&#39;, &#39;tag_base&#39; ), true ) ) {<br>		$value = untrailingslashit( $value );<br>	}<br><br>	/**<br>	 * Filters the value of an existing option.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 1.5.0 As &#39;option_&#39; . $setting<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 *<br>	 * @param mixed  $value  Value of the option. If stored serialized, it will be<br>	 *                       unserialized prior to being returned.<br>	 * @param string $option Option name.<br>	 */<br>	return apply_filters( &#34;option_{$option}&#34;, maybe_unserialize( $value ), $option );<br>}<br><br>/**<br> * Protects WordPress special option from being modified.<br> *<br> * Will die if $option is in protected list. Protected options are &#39;alloptions&#39;<br> * and &#39;notoptions&#39; options.<br> *<br> * @since 2.2.0<br> *<br> * @param string $option Option name.<br> */<br>function wp_protect_special_option( $option ) {<br>	if ( &#39;alloptions&#39; === $option || &#39;notoptions&#39; === $option ) {<br>		wp_die(<br>			sprintf(<br>				/* translators: %s: Option name. */<br>				__( &#39;%s is a protected WP option and may not be modified&#39; ),<br>				esc_html( $option )<br>			)<br>		);<br>	}<br>}<br><br>/**<br> * Prints option value after sanitizing for forms.<br> *<br> * @since 1.5.0<br> *<br> * @param string $option Option name.<br> */<br>function form_option( $option ) {<br>	echo esc_attr( get_option( $option ) );<br>}<br><br>/**<br> * Loads and caches all autoloaded options, if available or all options.<br> *<br> * @since 2.2.0<br> * @since 5.3.1 The `$force_cache` parameter was added.<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param bool $force_cache Optional. Whether to force an update of the local cache<br> *                          from the persistent cache. Default false.<br> * @return array List of all options.<br> */<br>function wp_load_alloptions( $force_cache = false ) {<br>	global $wpdb;<br><br>	if ( ! wp_installing() || ! is_multisite() ) {<br>		$alloptions = wp_cache_get( &#39;alloptions&#39;, &#39;options&#39;, $force_cache );<br>	} else {<br>		$alloptions = false;<br>	}<br><br>	if ( ! $alloptions ) {<br>		$suppress      = $wpdb-&gt;suppress_errors();<br>		$alloptions_db = $wpdb-&gt;get_results( &#34;SELECT option_name, option_value FROM $wpdb-&gt;options WHERE autoload = &#39;yes&#39;&#34; );<br>		if ( ! $alloptions_db ) {<br>			$alloptions_db = $wpdb-&gt;get_results( &#34;SELECT option_name, option_value FROM $wpdb-&gt;options&#34; );<br>		}<br>		$wpdb-&gt;suppress_errors( $suppress );<br><br>		$alloptions = array();<br>		foreach ( (array) $alloptions_db as $o ) {<br>			$alloptions[ $o-&gt;option_name ] = $o-&gt;option_value;<br>		}<br><br>		if ( ! wp_installing() || ! is_multisite() ) {<br>			/**<br>			 * Filters all options before caching them.<br>			 *<br>			 * @since 4.9.0<br>			 *<br>			 * @param array $alloptions Array with all options.<br>			 */<br>			$alloptions = apply_filters( &#39;pre_cache_alloptions&#39;, $alloptions );<br><br>			wp_cache_add( &#39;alloptions&#39;, $alloptions, &#39;options&#39; );<br>		}<br>	}<br><br>	/**<br>	 * Filters all options after retrieving them.<br>	 *<br>	 * @since 4.9.0<br>	 *<br>	 * @param array $alloptions Array with all options.<br>	 */<br>	return apply_filters( &#39;alloptions&#39;, $alloptions );<br>}<br><br>/**<br> * Loads and caches certain often requested site options if is_multisite() and a persistent cache is not being used.<br> *<br> * @since 3.0.0<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param int $network_id Optional site ID for which to query the options. Defaults to the current site.<br> */<br>function wp_load_core_site_options( $network_id = null ) {<br>	global $wpdb;<br><br>	if ( ! is_multisite() || wp_using_ext_object_cache() || wp_installing() ) {<br>		return;<br>	}<br><br>	if ( empty( $network_id ) ) {<br>		$network_id = get_current_network_id();<br>	}<br><br>	$core_options = array( &#39;site_name&#39;, &#39;siteurl&#39;, &#39;active_sitewide_plugins&#39;, &#39;_site_transient_timeout_theme_roots&#39;, &#39;_site_transient_theme_roots&#39;, &#39;site_admins&#39;, &#39;can_compress_scripts&#39;, &#39;global_terms_enabled&#39;, &#39;ms_files_rewriting&#39; );<br><br>	$core_options_in = &#34;&#39;&#34; . implode( &#34;&#39;, &#39;&#34;, $core_options ) . &#34;&#39;&#34;;<br>	$options         = $wpdb-&gt;get_results( $wpdb-&gt;prepare( &#34;SELECT meta_key, meta_value FROM $wpdb-&gt;sitemeta WHERE meta_key IN ($core_options_in) AND site_id = %d&#34;, $network_id ) );<br><br>	</span><ins class='diff-insert diff' style='background: #e6ffe6;'>$data = array();<br>	</ins><span class='diff'>foreach ( $options as $option ) {<br>		$key                = $option-&gt;meta_key;<br>		$cache_key          = &#34;{$network_id}:$key&#34;;<br>		$option-&gt;meta_value = maybe_unserialize( $option-&gt;meta_value );<br><br>		</span><del class='diff-delete diff' style='background: #ffe6e6'>wp_c</del><ins class='diff-insert diff' style='background: #e6ffe6;'>$d</ins><span class='diff'>a</span><del class='diff-delete diff' style='background: #ffe6e6'>che_se</del><span class='diff'>t</span><del class='diff-delete diff' style='background: #ffe6e6'>(</del><ins class='diff-insert diff' style='background: #e6ffe6;'>a[</ins><span class='diff'> $cache_key</span><del class='diff-delete diff' style='background: #ffe6e6'>,</del><ins class='diff-insert diff' style='background: #e6ffe6;'> ] =</ins><span class='diff'> $option-&gt;meta_value</span><ins class='diff-insert diff' style='background: #e6ffe6;'>;<br>	}<br>	wp_cache_set_multiple( $data</ins><span class='diff'>, &#39;site-options&#39; );</span><del class='diff-delete diff' style='background: #ffe6e6'><br>	}</del><span class='diff'><br>}<br><br>/**<br> * Updates the value of an option that was already added.<br> *<br> * You do not need to serialize values. If the value needs to be serialized,<br> * then it will be serialized before it is inserted into the database.<br> * Remember, resources cannot be serialized or added as an option.<br> *<br> * If the option does not exist, it will be created.<br><br> * This function is designed to work with or without a logged-in user. In terms of security,<br> * plugin developers should check the current user&#39;s capabilities before updating any options.<br> *<br> * @since 1.0.0<br> * @since 4.2.0 The `$autoload` parameter was added.<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param string      $option   Name of the option to update. Expected to not be SQL-escaped.<br> * @param mixed       $value    Option value. Must be serializable if non-scalar. Expected to not be SQL-escaped.<br> * @param string|bool $autoload Optional. Whether to load the option when WordPress starts up. For existing options,<br> *                              `$autoload` can only be updated using `update_option()` if `$value` is also changed.<br> *                              Accepts &#39;yes&#39;|true to enable or &#39;no&#39;|false to disable. For non-existent options,<br> *                              the default value is &#39;yes&#39;. Default null.<br> * @return bool True if the value was updated, false otherwise.<br> */<br>function update_option( $option, $value, $autoload = null ) {<br>	global $wpdb;<br><br>	if ( is_scalar( $option ) ) {<br>		$option = trim( $option );<br>	}<br><br>	if ( empty( $option ) ) {<br>		return false;<br>	}<br><br>	/*<br>	 * Until a proper _deprecated_option() function can be introduced,<br>	 * redirect requests to deprecated keys to the new, correct ones.<br>	 */<br>	$deprecated_keys = array(<br>		&#39;blacklist_keys&#39;    =&gt; &#39;disallowed_keys&#39;,<br>		&#39;comment_whitelist&#39; =&gt; &#39;comment_previously_approved&#39;,<br>	);<br><br>	if ( ! wp_installing() &amp;&amp; isset( $deprecated_keys[ $option ] ) ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;5.5.0&#39;,<br>			sprintf(<br>				/* translators: 1: Deprecated option key, 2: New option key. */<br>				__( &#39;The &#34;%1$s&#34; option key has been renamed to &#34;%2$s&#34;.&#39; ),<br>				$option,<br>				$deprecated_keys[ $option ]<br>			)<br>		);<br>		return update_option( $deprecated_keys[ $option ], $value, $autoload );<br>	}<br><br>	wp_protect_special_option( $option );<br><br>	if ( is_object( $value ) ) {<br>		$value = clone $value;<br>	}<br><br>	$value     = sanitize_option( $option, $value );<br>	$old_value = get_option( $option );<br><br>	/**<br>	 * Filters a specific option before its value is (maybe) serialized and updated.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.6.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 *<br>	 * @param mixed  $value     The new, unserialized option value.<br>	 * @param mixed  $old_value The old option value.<br>	 * @param string $option    Option name.<br>	 */<br>	$value = apply_filters( &#34;pre_update_option_{$option}&#34;, $value, $old_value, $option );<br><br>	/**<br>	 * Filters an option before its value is (maybe) serialized and updated.<br>	 *<br>	 * @since 3.9.0<br>	 *<br>	 * @param mixed  $value     The new, unserialized option value.<br>	 * @param string $option    Name of the option.<br>	 * @param mixed  $old_value The old option value.<br>	 */<br>	$value = apply_filters( &#39;pre_update_option&#39;, $value, $option, $old_value );<br><br>	/*<br>	 * If the new and old values are the same, no need to update.<br>	 *<br>	 * Unserialized values will be adequate in most cases. If the unserialized<br>	 * data differs, the (maybe) serialized data is checked to avoid<br>	 * unnecessary database calls for otherwise identical object instances.<br>	 *<br>	 * See https://core.trac.wordpress.org/ticket/38903<br>	 */<br>	if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) {<br>		return false;<br>	}<br><br>	/** This filter is documented in wp-includes/option.php */<br>	if ( apply_filters( &#34;default_option_{$option}&#34;, false, $option, false ) === $old_value ) {<br>		// Default setting for new options is &#39;yes&#39;.<br>		if ( null === $autoload ) {<br>			$autoload = &#39;yes&#39;;<br>		}<br><br>		return add_option( $option, $value, &#39;&#39;, $autoload );<br>	}<br><br>	$serialized_value = maybe_serialize( $value );<br><br>	/**<br>	 * Fires immediately before an option value is updated.<br>	 *<br>	 * @since 2.9.0<br>	 *<br>	 * @param string $option    Name of the option to update.<br>	 * @param mixed  $old_value The old option value.<br>	 * @param mixed  $value     The new option value.<br>	 */<br>	do_action( &#39;update_option&#39;, $option, $old_value, $value );<br><br>	$update_args = array(<br>		&#39;option_value&#39; =&gt; $serialized_value,<br>	);<br><br>	if ( null !== $autoload ) {<br>		$update_args[&#39;autoload&#39;] = ( &#39;no&#39; === $autoload || false === $autoload ) ? &#39;no&#39; : &#39;yes&#39;;<br>	}<br><br>	$result = $wpdb-&gt;update( $wpdb-&gt;options, $update_args, array( &#39;option_name&#39; =&gt; $option ) );<br>	if ( ! $result ) {<br>		return false;<br>	}<br><br>	$notoptions = wp_cache_get( &#39;notoptions&#39;, &#39;options&#39; );<br><br>	if ( is_array( $notoptions ) &amp;&amp; isset( $notoptions[ $option ] ) ) {<br>		unset( $notoptions[ $option ] );<br>		wp_cache_set( &#39;notoptions&#39;, $notoptions, &#39;options&#39; );<br>	}<br><br>	if ( ! wp_installing() ) {<br>		$alloptions = wp_load_alloptions( true );<br>		if ( isset( $alloptions[ $option ] ) ) {<br>			$alloptions[ $option ] = $serialized_value;<br>			wp_cache_set( &#39;alloptions&#39;, $alloptions, &#39;options&#39; );<br>		} else {<br>			wp_cache_set( $option, $serialized_value, &#39;options&#39; );<br>		}<br>	}<br><br>	/**<br>	 * Fires after the value of a specific option has been successfully updated.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.0.1<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 *<br>	 * @param mixed  $old_value The old option value.<br>	 * @param mixed  $value     The new option value.<br>	 * @param string $option    Option name.<br>	 */<br>	do_action( &#34;update_option_{$option}&#34;, $old_value, $value, $option );<br><br>	/**<br>	 * Fires after the value of an option has been successfully updated.<br>	 *<br>	 * @since 2.9.0<br>	 *<br>	 * @param string $option    Name of the updated option.<br>	 * @param mixed  $old_value The old option value.<br>	 * @param mixed  $value     The new option value.<br>	 */<br>	do_action( &#39;updated_option&#39;, $option, $old_value, $value );<br><br>	return true;<br>}<br><br>/**<br> * Adds a new option.<br> *<br> * You do not need to serialize values. If the value needs to be serialized,<br> * then it will be serialized before it is inserted into the database.<br> * Remember, resources cannot be serialized or added as an option.<br> *<br> * You can create options without values and then update the values later.<br> * Existing options will not be updated and checks are performed to ensure that you<br> * aren&#39;t adding a protected WordPress option. Care should be taken to not name<br> * options the same as the ones which are protected.<br> *<br> * @since 1.0.0<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param string      $option     Name of the option to add. Expected to not be SQL-escaped.<br> * @param mixed       $value      Optional. Option value. Must be serializable if non-scalar.<br> *                                Expected to not be SQL-escaped.<br> * @param string      $deprecated Optional. Description. Not used anymore.<br> * @param string|bool $autoload   Optional. Whether to load the option when WordPress starts up.<br> *                                Default is enabled. Accepts &#39;no&#39; to disable for legacy reasons.<br> * @return bool True if the option was added, false otherwise.<br> */<br>function add_option( $option, $value = &#39;&#39;, $deprecated = &#39;&#39;, $autoload = &#39;yes&#39; ) {<br>	global $wpdb;<br><br>	if ( ! empty( $deprecated ) ) {<br>		_deprecated_argument( __FUNCTION__, &#39;2.3.0&#39; );<br>	}<br><br>	if ( is_scalar( $option ) ) {<br>		$option = trim( $option );<br>	}<br><br>	if ( empty( $option ) ) {<br>		return false;<br>	}<br><br>	/*<br>	 * Until a proper _deprecated_option() function can be introduced,<br>	 * redirect requests to deprecated keys to the new, correct ones.<br>	 */<br>	$deprecated_keys = array(<br>		&#39;blacklist_keys&#39;    =&gt; &#39;disallowed_keys&#39;,<br>		&#39;comment_whitelist&#39; =&gt; &#39;comment_previously_approved&#39;,<br>	);<br><br>	if ( ! wp_installing() &amp;&amp; isset( $deprecated_keys[ $option ] ) ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;5.5.0&#39;,<br>			sprintf(<br>				/* translators: 1: Deprecated option key, 2: New option key. */<br>				__( &#39;The &#34;%1$s&#34; option key has been renamed to &#34;%2$s&#34;.&#39; ),<br>				$option,<br>				$deprecated_keys[ $option ]<br>			)<br>		);<br>		return add_option( $deprecated_keys[ $option ], $value, $deprecated, $autoload );<br>	}<br><br>	wp_protect_special_option( $option );<br><br>	if ( is_object( $value ) ) {<br>		$value = clone $value;<br>	}<br><br>	$value = sanitize_option( $option, $value );<br><br>	// Make sure the option doesn&#39;t already exist.<br>	// We can check the &#39;notoptions&#39; cache before we ask for a DB query.<br>	$notoptions = wp_cache_get( &#39;notoptions&#39;, &#39;options&#39; );<br><br>	if ( ! is_array( $notoptions ) || ! isset( $notoptions[ $option ] ) ) {<br>		/** This filter is documented in wp-includes/option.php */<br>		if ( apply_filters( &#34;default_option_{$option}&#34;, false, $option, false ) !== get_option( $option ) ) {<br>			return false;<br>		}<br>	}<br><br>	$serialized_value = maybe_serialize( $value );<br>	$autoload         = ( &#39;no&#39; === $autoload || false === $autoload ) ? &#39;no&#39; : &#39;yes&#39;;<br><br>	/**<br>	 * Fires before an option is added.<br>	 *<br>	 * @since 2.9.0<br>	 *<br>	 * @param string $option Name of the option to add.<br>	 * @param mixed  $value  Value of the option.<br>	 */<br>	do_action( &#39;add_option&#39;, $option, $value );<br><br>	$result = $wpdb-&gt;query( $wpdb-&gt;prepare( &#34;INSERT INTO `$wpdb-&gt;options` (`option_name`, `option_value`, `autoload`) VALUES (%s, %s, %s) ON DUPLICATE KEY UPDATE `option_name` = VALUES(`option_name`), `option_value` = VALUES(`option_value`), `autoload` = VALUES(`autoload`)&#34;, $option, $serialized_value, $autoload ) );<br>	if ( ! $result ) {<br>		return false;<br>	}<br><br>	if ( ! wp_installing() ) {<br>		if ( &#39;yes&#39; === $autoload ) {<br>			$alloptions            = wp_load_alloptions( true );<br>			$alloptions[ $option ] = $serialized_value;<br>			wp_cache_set( &#39;alloptions&#39;, $alloptions, &#39;options&#39; );<br>		} else {<br>			wp_cache_set( $option, $serialized_value, &#39;options&#39; );<br>		}<br>	}<br><br>	// This option exists now.<br>	$notoptions = wp_cache_get( &#39;notoptions&#39;, &#39;options&#39; ); // Yes, again... we need it to be fresh.<br><br>	if ( is_array( $notoptions ) &amp;&amp; isset( $notoptions[ $option ] ) ) {<br>		unset( $notoptions[ $option ] );<br>		wp_cache_set( &#39;notoptions&#39;, $notoptions, &#39;options&#39; );<br>	}<br><br>	/**<br>	 * Fires after a specific option has been added.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.5.0 As &#34;add_option_{$name}&#34;<br>	 * @since 3.0.0<br>	 *<br>	 * @param string $option Name of the option to add.<br>	 * @param mixed  $value  Value of the option.<br>	 */<br>	do_action( &#34;add_option_{$option}&#34;, $option, $value );<br><br>	/**<br>	 * Fires after an option has been added.<br>	 *<br>	 * @since 2.9.0<br>	 *<br>	 * @param string $option Name of the added option.<br>	 * @param mixed  $value  Value of the option.<br>	 */<br>	do_action( &#39;added_option&#39;, $option, $value );<br><br>	return true;<br>}<br><br>/**<br> * Removes option by name. Prevents removal of protected WordPress options.<br> *<br> * @since 1.2.0<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param string $option Name of the option to delete. Expected to not be SQL-escaped.<br> * @return bool True if the option was deleted, false otherwise.<br> */<br>function delete_option( $option ) {<br>	global $wpdb;<br><br>	if ( is_scalar( $option ) ) {<br>		$option = trim( $option );<br>	}<br><br>	if ( empty( $option ) ) {<br>		return false;<br>	}<br><br>	wp_protect_special_option( $option );<br><br>	// Get the ID, if no ID then return.<br>	$row = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &#34;SELECT autoload FROM $wpdb-&gt;options WHERE option_name = %s&#34;, $option ) );<br>	if ( is_null( $row ) ) {<br>		return false;<br>	}<br><br>	/**<br>	 * Fires immediately before an option is deleted.<br>	 *<br>	 * @since 2.9.0<br>	 *<br>	 * @param string $option Name of the option to delete.<br>	 */<br>	do_action( &#39;delete_option&#39;, $option );<br><br>	$result = $wpdb-&gt;delete( $wpdb-&gt;options, array( &#39;option_name&#39; =&gt; $option ) );<br><br>	if ( ! wp_installing() ) {<br>		if ( &#39;yes&#39; === $row-&gt;autoload ) {<br>			$alloptions = wp_load_alloptions( true );<br>			if ( is_array( $alloptions ) &amp;&amp; isset( $alloptions[ $option ] ) ) {<br>				unset( $alloptions[ $option ] );<br>				wp_cache_set( &#39;alloptions&#39;, $alloptions, &#39;options&#39; );<br>			}<br>		} else {<br>			wp_cache_delete( $option, &#39;options&#39; );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after a specific option has been deleted.<br>		 *<br>		 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>		 *<br>		 * @since 3.0.0<br>		 *<br>		 * @param string $option Name of the deleted option.<br>		 */<br>		do_action( &#34;delete_option_{$option}&#34;, $option );<br><br>		/**<br>		 * Fires after an option has been deleted.<br>		 *<br>		 * @since 2.9.0<br>		 *<br>		 * @param string $option Name of the deleted option.<br>		 */<br>		do_action( &#39;deleted_option&#39;, $option );<br><br>		return true;<br>	}<br><br>	return false;<br>}<br><br>/**<br> * Deletes a transient.<br> *<br> * @since 2.8.0<br> *<br> * @param string $transient Transient name. Expected to not be SQL-escaped.<br> * @return bool True if the transient was deleted, false otherwise.<br> */<br>function delete_transient( $transient ) {<br><br>	/**<br>	 * Fires immediately before a specific transient is deleted.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 3.0.0<br>	 *<br>	 * @param string $transient Transient name.<br>	 */<br>	do_action( &#34;delete_transient_{$transient}&#34;, $transient );<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$result = wp_cache_delete( $transient, &#39;transient&#39; );<br>	} else {<br>		$option_timeout = &#39;_transient_timeout_&#39; . $transient;<br>		$option         = &#39;_transient_&#39; . $transient;<br>		$result         = delete_option( $option );<br><br>		if ( $result ) {<br>			delete_option( $option_timeout );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after a transient is deleted.<br>		 *<br>		 * @since 3.0.0<br>		 *<br>		 * @param string $transient Deleted transient name.<br>		 */<br>		do_action( &#39;deleted_transient&#39;, $transient );<br>	}<br><br>	return $result;<br>}<br><br>/**<br> * Retrieves the value of a transient.<br> *<br> * If the transient does not exist, does not have a value, or has expired,<br> * then the return value will be false.<br> *<br> * @since 2.8.0<br> *<br> * @param string $transient Transient name. Expected to not be SQL-escaped.<br> * @return mixed Value of transient.<br> */<br>function get_transient( $transient ) {<br><br>	/**<br>	 * Filters the value of an existing transient before it is retrieved.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * Returning a truthy value from the filter will effectively short-circuit retrieval<br>	 * and return the passed value instead.<br>	 *<br>	 * @since 2.8.0<br>	 * @since 4.4.0 The `$transient` parameter was added<br>	 *<br>	 * @param mixed  $pre_transient The default value to return if the transient does not exist.<br>	 *                              Any value other than false will short-circuit the retrieval<br>	 *                              of the transient, and return that value.<br>	 * @param string $transient     Transient name.<br>	 */<br>	$pre = apply_filters( &#34;pre_transient_{$transient}&#34;, false, $transient );<br><br>	if ( false !== $pre ) {<br>		return $pre;<br>	}<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$value = wp_cache_get( $transient, &#39;transient&#39; );<br>	} else {<br>		$transient_option = &#39;_transient_&#39; . $transient;<br>		if ( ! wp_installing() ) {<br>			// If option is not in alloptions, it is not autoloaded and thus has a timeout.<br>			$alloptions = wp_load_alloptions();<br>			if ( ! isset( $alloptions[ $transient_option ] ) ) {<br>				$transient_timeout = &#39;_transient_timeout_&#39; . $transient;<br>				$timeout           = get_option( $transient_timeout );<br>				if ( false !== $timeout &amp;&amp; $timeout &lt; time() ) {<br>					delete_option( $transient_option );<br>					delete_option( $transient_timeout );<br>					$value = false;<br>				}<br>			}<br>		}<br><br>		if ( ! isset( $value ) ) {<br>			$value = get_option( $transient_option );<br>		}<br>	}<br><br>	/**<br>	 * Filters an existing transient&#39;s value.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 2.8.0<br>	 * @since 4.4.0 The `$transient` parameter was added<br>	 *<br>	 * @param mixed  $value     Value of transient.<br>	 * @param string $transient Transient name.<br>	 */<br>	return apply_filters( &#34;transient_{$transient}&#34;, $value, $transient );<br>}<br><br>/**<br> * Sets/updates the value of a transient.<br> *<br> * You do not need to serialize values. If the value needs to be serialized,<br> * then it will be serialized before it is set.<br> *<br> * @since 2.8.0<br> *<br> * @param string $transient  Transient name. Expected to not be SQL-escaped.<br> *                           Must be 172 characters or fewer in length.<br> * @param mixed  $value      Transient value. Must be serializable if non-scalar.<br> *                           Expected to not be SQL-escaped.<br> * @param int    $expiration Optional. Time until expiration in seconds. Default 0 (no expiration).<br> * @return bool True if the value was set, false otherwise.<br> */<br>function set_transient( $transient, $value, $expiration = 0 ) {<br><br>	$expiration = (int) $expiration;<br><br>	/**<br>	 * Filters a specific transient before its value is set.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 3.0.0<br>	 * @since 4.2.0 The `$expiration` parameter was added.<br>	 * @since 4.4.0 The `$transient` parameter was added.<br>	 *<br>	 * @param mixed  $value      New value of transient.<br>	 * @param int    $expiration Time until expiration in seconds.<br>	 * @param string $transient  Transient name.<br>	 */<br>	$value = apply_filters( &#34;pre_set_transient_{$transient}&#34;, $value, $expiration, $transient );<br><br>	/**<br>	 * Filters the expiration for a transient before its value is set.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 4.4.0<br>	 *<br>	 * @param int    $expiration Time until expiration in seconds. Use 0 for no expiration.<br>	 * @param mixed  $value      New value of transient.<br>	 * @param string $transient  Transient name.<br>	 */<br>	$expiration = apply_filters( &#34;expiration_of_transient_{$transient}&#34;, $expiration, $value, $transient );<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$result = wp_cache_set( $transient, $value, &#39;transient&#39;, $expiration );<br>	} else {<br>		$transient_timeout = &#39;_transient_timeout_&#39; . $transient;<br>		$transient_option  = &#39;_transient_&#39; . $transient;<br><br>		if ( false === get_option( $transient_option ) ) {<br>			$autoload = &#39;yes&#39;;<br>			if ( $expiration ) {<br>				$autoload = &#39;no&#39;;<br>				add_option( $transient_timeout, time() + $expiration, &#39;&#39;, &#39;no&#39; );<br>			}<br>			$result = add_option( $transient_option, $value, &#39;&#39;, $autoload );<br>		} else {<br>			// If expiration is requested, but the transient has no timeout option,<br>			// delete, then re-create transient rather than update.<br>			$update = true;<br><br>			if ( $expiration ) {<br>				if ( false === get_option( $transient_timeout ) ) {<br>					delete_option( $transient_option );<br>					add_option( $transient_timeout, time() + $expiration, &#39;&#39;, &#39;no&#39; );<br>					$result = add_option( $transient_option, $value, &#39;&#39;, &#39;no&#39; );<br>					$update = false;<br>				} else {<br>					update_option( $transient_timeout, time() + $expiration );<br>				}<br>			}<br><br>			if ( $update ) {<br>				$result = update_option( $transient_option, $value );<br>			}<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after the value for a specific transient has been set.<br>		 *<br>		 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 3.6.0 The `$value` and `$expiration` parameters were added.<br>		 * @since 4.4.0 The `$transient` parameter was added.<br>		 *<br>		 * @param mixed  $value      Transient value.<br>		 * @param int    $expiration Time until expiration in seconds.<br>		 * @param string $transient  The name of the transient.<br>		 */<br>		do_action( &#34;set_transient_{$transient}&#34;, $value, $expiration, $transient );<br><br>		/**<br>		 * Fires after the value for a transient has been set.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 3.6.0 The `$value` and `$expiration` parameters were added.<br>		 *<br>		 * @param string $transient  The name of the transient.<br>		 * @param mixed  $value      Transient value.<br>		 * @param int    $expiration Time until expiration in seconds.<br>		 */<br>		do_action( &#39;setted_transient&#39;, $transient, $value, $expiration );<br>	}<br><br>	return $result;<br>}<br><br>/**<br> * Deletes all expired transients.<br> *<br> * The multi-table delete syntax is used to delete the transient record<br> * from table a, and the corresponding transient_timeout record from table b.<br> *<br> * @since 4.9.0<br> *<br> * @param bool $force_db Optional. Force cleanup to run against the database even when an external object cache is used.<br> */<br>function delete_expired_transients( $force_db = false ) {<br>	global $wpdb;<br><br>	if ( ! $force_db &amp;&amp; wp_using_ext_object_cache() ) {<br>		return;<br>	}<br><br>	$wpdb-&gt;query(<br>		$wpdb-&gt;prepare(<br>			&#34;DELETE a, b FROM {$wpdb-&gt;options} a, {$wpdb-&gt;options} b<br>			WHERE a.option_name LIKE %s<br>			AND a.option_name NOT LIKE %s<br>			AND b.option_name = CONCAT( &#39;_transient_timeout_&#39;, SUBSTRING( a.option_name, 12 ) )<br>			AND b.option_value &lt; %d&#34;,<br>			$wpdb-&gt;esc_like( &#39;_transient_&#39; ) . &#39;%&#39;,<br>			$wpdb-&gt;esc_like( &#39;_transient_timeout_&#39; ) . &#39;%&#39;,<br>			time()<br>		)<br>	);<br><br>	if ( ! is_multisite() ) {<br>		// Single site stores site transients in the options table.<br>		$wpdb-&gt;query(<br>			$wpdb-&gt;prepare(<br>				&#34;DELETE a, b FROM {$wpdb-&gt;options} a, {$wpdb-&gt;options} b<br>				WHERE a.option_name LIKE %s<br>				AND a.option_name NOT LIKE %s<br>				AND b.option_name = CONCAT( &#39;_site_transient_timeout_&#39;, SUBSTRING( a.option_name, 17 ) )<br>				AND b.option_value &lt; %d&#34;,<br>				$wpdb-&gt;esc_like( &#39;_site_transient_&#39; ) . &#39;%&#39;,<br>				$wpdb-&gt;esc_like( &#39;_site_transient_timeout_&#39; ) . &#39;%&#39;,<br>				time()<br>			)<br>		);<br>	} elseif ( is_multisite() &amp;&amp; is_main_site() &amp;&amp; is_main_network() ) {<br>		// Multisite stores site transients in the sitemeta table.<br>		$wpdb-&gt;query(<br>			$wpdb-&gt;prepare(<br>				&#34;DELETE a, b FROM {$wpdb-&gt;sitemeta} a, {$wpdb-&gt;sitemeta} b<br>				WHERE a.meta_key LIKE %s<br>				AND a.meta_key NOT LIKE %s<br>				AND b.meta_key = CONCAT( &#39;_site_transient_timeout_&#39;, SUBSTRING( a.meta_key, 17 ) )<br>				AND b.meta_value &lt; %d&#34;,<br>				$wpdb-&gt;esc_like( &#39;_site_transient_&#39; ) . &#39;%&#39;,<br>				$wpdb-&gt;esc_like( &#39;_site_transient_timeout_&#39; ) . &#39;%&#39;,<br>				time()<br>			)<br>		);<br>	}<br>}<br><br>/**<br> * Saves and restores user interface settings stored in a cookie.<br> *<br> * Checks if the current user-settings cookie is updated and stores it. When no<br> * cookie exists (different browser used), adds the last saved cookie restoring<br> * the settings.<br> *<br> * @since 2.7.0<br> */<br>function wp_user_settings() {<br><br>	if ( ! is_admin() || wp_doing_ajax() ) {<br>		return;<br>	}<br><br>	$user_id = get_current_user_id();<br>	if ( ! $user_id ) {<br>		return;<br>	}<br><br>	if ( ! is_user_member_of_blog() ) {<br>		return;<br>	}<br><br>	$settings = (string) get_user_option( &#39;user-settings&#39;, $user_id );<br><br>	if ( isset( $_COOKIE[ &#39;wp-settings-&#39; . $user_id ] ) ) {<br>		$cookie = preg_replace( &#39;/[^A-Za-z0-9=&amp;_]/&#39;, &#39;&#39;, $_COOKIE[ &#39;wp-settings-&#39; . $user_id ] );<br><br>		// No change or both empty.<br>		if ( $cookie == $settings ) {<br>			return;<br>		}<br><br>		$last_saved = (int) get_user_option( &#39;user-settings-time&#39;, $user_id );<br>		$current    = isset( $_COOKIE[ &#39;wp-settings-time-&#39; . $user_id ] ) ? preg_replace( &#39;/[^0-9]/&#39;, &#39;&#39;, $_COOKIE[ &#39;wp-settings-time-&#39; . $user_id ] ) : 0;<br><br>		// The cookie is newer than the saved value. Update the user_option and leave the cookie as-is.<br>		if ( $current &gt; $last_saved ) {<br>			update_user_option( $user_id, &#39;user-settings&#39;, $cookie, false );<br>			update_user_option( $user_id, &#39;user-settings-time&#39;, time() - 5, false );<br>			return;<br>		}<br>	}<br><br>	// The cookie is not set in the current browser or the saved value is newer.<br>	$secure = ( &#39;https&#39; === parse_url( admin_url(), PHP_URL_SCHEME ) );<br>	setcookie( &#39;wp-settings-&#39; . $user_id, $settings, time() + YEAR_IN_SECONDS, SITECOOKIEPATH, null, $secure );<br>	setcookie( &#39;wp-settings-time-&#39; . $user_id, time(), time() + YEAR_IN_SECONDS, SITECOOKIEPATH, null, $secure );<br>	$_COOKIE[ &#39;wp-settings-&#39; . $user_id ] = $settings;<br>}<br><br>/**<br> * Retrieves user interface setting value based on setting name.<br> *<br> * @since 2.7.0<br> *<br> * @param string       $name    The name of the setting.<br> * @param string|false $default Optional. Default value to return when $name is not set. Default false.<br> * @return mixed The last saved user setting or the default value/false if it doesn&#39;t exist.<br> */<br>function get_user_setting( $name, $default = false ) {<br>	$all_user_settings = get_all_user_settings();<br><br>	return isset( $all_user_settings[ $name ] ) ? $all_user_settings[ $name ] : $default;<br>}<br><br>/**<br> * Adds or updates user interface setting.<br> *<br> * Both $name and $value can contain only ASCII letters, numbers, hyphens, and underscores.<br> *<br> * This function has to be used before any output has started as it calls setcookie().<br> *<br> * @since 2.8.0<br> *<br> * @param string $name  The name of the setting.<br> * @param string $value The value for the setting.<br> * @return bool|null True if set successfully, false otherwise.<br> *                   Null if the current user is not a member of the site.<br> */<br>function set_user_setting( $name, $value ) {<br>	if ( headers_sent() ) {<br>		return false;<br>	}<br><br>	$all_user_settings          = get_all_user_settings();<br>	$all_user_settings[ $name ] = $value;<br><br>	return wp_set_all_user_settings( $all_user_settings );<br>}<br><br>/**<br> * Deletes user interface settings.<br> *<br> * Deleting settings would reset them to the defaults.<br> *<br> * This function has to be used before any output has started as it calls setcookie().<br> *<br> * @since 2.7.0<br> *<br> * @param string $names The name or array of names of the setting to be deleted.<br> * @return bool|null True if deleted successfully, false otherwise.<br> *                   Null if the current user is not a member of the site.<br> */<br>function delete_user_setting( $names ) {<br>	if ( headers_sent() ) {<br>		return false;<br>	}<br><br>	$all_user_settings = get_all_user_settings();<br>	$names             = (array) $names;<br>	$deleted           = false;<br><br>	foreach ( $names as $name ) {<br>		if ( isset( $all_user_settings[ $name ] ) ) {<br>			unset( $all_user_settings[ $name ] );<br>			$deleted = true;<br>		}<br>	}<br><br>	if ( $deleted ) {<br>		return wp_set_all_user_settings( $all_user_settings );<br>	}<br><br>	return false;<br>}<br><br>/**<br> * Retrieves all user interface settings.<br> *<br> * @since 2.7.0<br> *<br> * @global array $_updated_user_settings<br> *<br> * @return array The last saved user settings or empty array.<br> */<br>function get_all_user_settings() {<br>	global $_updated_user_settings;<br><br>	$user_id = get_current_user_id();<br>	if ( ! $user_id ) {<br>		return array();<br>	}<br><br>	if ( isset( $_updated_user_settings ) &amp;&amp; is_array( $_updated_user_settings ) ) {<br>		return $_updated_user_settings;<br>	}<br><br>	$user_settings = array();<br><br>	if ( isset( $_COOKIE[ &#39;wp-settings-&#39; . $user_id ] ) ) {<br>		$cookie = preg_replace( &#39;/[^A-Za-z0-9=&amp;_-]/&#39;, &#39;&#39;, $_COOKIE[ &#39;wp-settings-&#39; . $user_id ] );<br><br>		if ( strpos( $cookie, &#39;=&#39; ) ) { // &#39;=&#39; cannot be 1st char.<br>			parse_str( $cookie, $user_settings );<br>		}<br>	} else {<br>		$option = get_user_option( &#39;user-settings&#39;, $user_id );<br><br>		if ( $option &amp;&amp; is_string( $option ) ) {<br>			parse_str( $option, $user_settings );<br>		}<br>	}<br><br>	$_updated_user_settings = $user_settings;<br>	return $user_settings;<br>}<br><br>/**<br> * Private. Sets all user interface settings.<br> *<br> * @since 2.8.0<br> * @access private<br> *<br> * @global array $_updated_user_settings<br> *<br> * @param array $user_settings User settings.<br> * @return bool|null True if set successfully, false if the current user could not be found.<br> *                   Null if the current user is not a member of the site.<br> */<br>function wp_set_all_user_settings( $user_settings ) {<br>	global $_updated_user_settings;<br><br>	$user_id = get_current_user_id();<br>	if ( ! $user_id ) {<br>		return false;<br>	}<br><br>	if ( ! is_user_member_of_blog() ) {<br>		return;<br>	}<br><br>	$settings = &#39;&#39;;<br>	foreach ( $user_settings as $name =&gt; $value ) {<br>		$_name  = preg_replace( &#39;/[^A-Za-z0-9_-]+/&#39;, &#39;&#39;, $name );<br>		$_value = preg_replace( &#39;/[^A-Za-z0-9_-]+/&#39;, &#39;&#39;, $value );<br><br>		if ( ! empty( $_name ) ) {<br>			$settings .= $_name . &#39;=&#39; . $_value . &#39;&amp;&#39;;<br>		}<br>	}<br><br>	$settings = rtrim( $settings, &#39;&amp;&#39; );<br>	parse_str( $settings, $_updated_user_settings );<br><br>	update_user_option( $user_id, &#39;user-settings&#39;, $settings, false );<br>	update_user_option( $user_id, &#39;user-settings-time&#39;, time(), false );<br><br>	return true;<br>}<br><br>/**<br> * Deletes the user settings of the current user.<br> *<br> * @since 2.7.0<br> */<br>function delete_all_user_settings() {<br>	$user_id = get_current_user_id();<br>	if ( ! $user_id ) {<br>		return;<br>	}<br><br>	update_user_option( $user_id, &#39;user-settings&#39;, &#39;&#39;, false );<br>	setcookie( &#39;wp-settings-&#39; . $user_id, &#39; &#39;, time() - YEAR_IN_SECONDS, SITECOOKIEPATH );<br>}<br><br>/**<br> * Retrieve an option value for the current network based on name of option.<br> *<br> * @since 2.8.0<br> * @since 4.4.0 The `$use_cache` parameter was deprecated.<br> * @since 4.4.0 Modified into wrapper for get_network_option()<br> *<br> * @see get_network_option()<br> *<br> * @param string $option     Name of the option to retrieve. Expected to not be SQL-escaped.<br> * @param mixed  $default    Optional. Value to return if the option doesn&#39;t exist. Default false.<br> * @param bool   $deprecated Whether to use cache. Multisite only. Always set to true.<br> * @return mixed Value set for the option.<br> */<br>function get_site_option( $option, $default = false, $deprecated = true ) {<br>	return get_network_option( null, $option, $default );<br>}<br><br>/**<br> * Adds a new option for the current network.<br> *<br> * Existing options will not be updated. Note that prior to 3.3 this wasn&#39;t the case.<br> *<br> * @since 2.8.0<br> * @since 4.4.0 Modified into wrapper for add_network_option()<br> *<br> * @see add_network_option()<br> *<br> * @param string $option Name of the option to add. Expected to not be SQL-escaped.<br> * @param mixed  $value  Option value, can be anything. Expected to not be SQL-escaped.<br> * @return bool True if the option was added, false otherwise.<br> */<br>function add_site_option( $option, $value ) {<br>	return add_network_option( null, $option, $value );<br>}<br><br>/**<br> * Removes a option by name for the current network.<br> *<br> * @since 2.8.0<br> * @since 4.4.0 Modified into wrapper for delete_network_option()<br> *<br> * @see delete_network_option()<br> *<br> * @param string $option Name of the option to delete. Expected to not be SQL-escaped.<br> * @return bool True if the option was deleted, false otherwise.<br> */<br>function delete_site_option( $option ) {<br>	return delete_network_option( null, $option );<br>}<br><br>/**<br> * Updates the value of an option that was already added for the current network.<br> *<br> * @since 2.8.0<br> * @since 4.4.0 Modified into wrapper for update_network_option()<br> *<br> * @see update_network_option()<br> *<br> * @param string $option Name of the option. Expected to not be SQL-escaped.<br> * @param mixed  $value  Option value. Expected to not be SQL-escaped.<br> * @return bool True if the value was updated, false otherwise.<br> */<br>function update_site_option( $option, $value ) {<br>	return update_network_option( null, $option, $value );<br>}<br><br>/**<br> * Retrieves a network&#39;s option value based on the option name.<br> *<br> * @since 4.4.0<br> *<br> * @see get_option()<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param int    $network_id ID of the network. Can be null to default to the current network ID.<br> * @param string $option     Name of the option to retrieve. Expected to not be SQL-escaped.<br> * @param mixed  $default    Optional. Value to return if the option doesn&#39;t exist. Default false.<br> * @return mixed Value set for the option.<br> */<br>function get_network_option( $network_id, $option, $default = false ) {<br>	global $wpdb;<br><br>	if ( $network_id &amp;&amp; ! is_numeric( $network_id ) ) {<br>		return false;<br>	}<br><br>	$network_id = (int) $network_id;<br><br>	// Fallback to the current network if a network ID is not specified.<br>	if ( ! $network_id ) {<br>		$network_id = get_current_network_id();<br>	}<br><br>	/**<br>	 * Filters the value of an existing network option before it is retrieved.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * Returning a truthy value from the filter will effectively short-circuit retrieval<br>	 * and return the passed value instead.<br>	 *<br>	 * @since 2.9.0 As &#39;pre_site_option_&#39; . $key<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.7.0 The `$network_id` parameter was added.<br>	 * @since 4.9.0 The `$default` parameter was added.<br>	 *<br>	 * @param mixed  $pre_option The value to return instead of the option value. This differs<br>	 *                           from `$default`, which is used as the fallback value in the event<br>	 *                           the option doesn&#39;t exist elsewhere in get_network_option().<br>	 *                           Default false (to skip past the short-circuit).<br>	 * @param string $option     Option name.<br>	 * @param int    $network_id ID of the network.<br>	 * @param mixed  $default    The fallback value to return if the option does not exist.<br>	 *                           Default false.<br>	 */<br>	$pre = apply_filters( &#34;pre_site_option_{$option}&#34;, false, $option, $network_id, $default );<br><br>	if ( false !== $pre ) {<br>		return $pre;<br>	}<br><br>	// Prevent non-existent options from triggering multiple queries.<br>	$notoptions_key = &#34;$network_id:notoptions&#34;;<br>	$notoptions     = wp_cache_get( $notoptions_key, &#39;site-options&#39; );<br><br>	if ( is_array( $notoptions ) &amp;&amp; isset( $notoptions[ $option ] ) ) {<br><br>		/**<br>		 * Filters a specific default network option.<br>		 *<br>		 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>		 *<br>		 * @since 3.4.0<br>		 * @since 4.4.0 The `$option` parameter was added.<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param mixed  $default    The value to return if the site option does not exist<br>		 *                           in the database.<br>		 * @param string $option     Option name.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		return apply_filters( &#34;default_site_option_{$option}&#34;, $default, $option, $network_id );<br>	}<br><br>	if ( ! is_multisite() ) {<br>		/** This filter is documented in wp-includes/option.php */<br>		$default = apply_filters( &#39;default_site_option_&#39; . $option, $default, $option, $network_id );<br>		$value   = get_option( $option, $default );<br>	} else {<br>		$cache_key = &#34;$network_id:$option&#34;;<br>		$value     = wp_cache_get( $cache_key, &#39;site-options&#39; );<br><br>		if ( ! isset( $value ) || false === $value ) {<br>			$row = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &#34;SELECT meta_value FROM $wpdb-&gt;sitemeta WHERE meta_key = %s AND site_id = %d&#34;, $option, $network_id ) );<br><br>			// Has to be get_row() instead of get_var() because of funkiness with 0, false, null values.<br>			if ( is_object( $row ) ) {<br>				$value = $row-&gt;meta_value;<br>				$value = maybe_unserialize( $value );<br>				wp_cache_set( $cache_key, $value, &#39;site-options&#39; );<br>			} else {<br>				if ( ! is_array( $notoptions ) ) {<br>					$notoptions = array();<br>				}<br><br>				$notoptions[ $option ] = true;<br>				wp_cache_set( $notoptions_key, $notoptions, &#39;site-options&#39; );<br><br>				/** This filter is documented in wp-includes/option.php */<br>				$value = apply_filters( &#39;default_site_option_&#39; . $option, $default, $option, $network_id );<br>			}<br>		}<br>	}<br><br>	if ( ! is_array( $notoptions ) ) {<br>		$notoptions = array();<br>		wp_cache_set( $notoptions_key, $notoptions, &#39;site-options&#39; );<br>	}<br><br>	/**<br>	 * Filters the value of an existing network option.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.9.0 As &#39;site_option_&#39; . $key<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.7.0 The `$network_id` parameter was added.<br>	 *<br>	 * @param mixed  $value      Value of network option.<br>	 * @param string $option     Option name.<br>	 * @param int    $network_id ID of the network.<br>	 */<br>	return apply_filters( &#34;site_option_{$option}&#34;, $value, $option, $network_id );<br>}<br><br>/**<br> * Adds a new network option.<br> *<br> * Existing options will not be updated.<br> *<br> * @since 4.4.0<br> *<br> * @see add_option()<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param int    $network_id ID of the network. Can be null to default to the current network ID.<br> * @param string $option     Name of the option to add. Expected to not be SQL-escaped.<br> * @param mixed  $value      Option value, can be anything. Expected to not be SQL-escaped.<br> * @return bool True if the option was added, false otherwise.<br> */<br>function add_network_option( $network_id, $option, $value ) {<br>	global $wpdb;<br><br>	if ( $network_id &amp;&amp; ! is_numeric( $network_id ) ) {<br>		return false;<br>	}<br><br>	$network_id = (int) $network_id;<br><br>	// Fallback to the current network if a network ID is not specified.<br>	if ( ! $network_id ) {<br>		$network_id = get_current_network_id();<br>	}<br><br>	wp_protect_special_option( $option );<br><br>	/**<br>	 * Filters the value of a specific network option before it is added.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.9.0 As &#39;pre_add_site_option_&#39; . $key<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.7.0 The `$network_id` parameter was added.<br>	 *<br>	 * @param mixed  $value      Value of network option.<br>	 * @param string $option     Option name.<br>	 * @param int    $network_id ID of the network.<br>	 */<br>	$value = apply_filters( &#34;pre_add_site_option_{$option}&#34;, $value, $option, $network_id );<br><br>	$notoptions_key = &#34;$network_id:notoptions&#34;;<br><br>	if ( ! is_multisite() ) {<br>		$result = add_option( $option, $value, &#39;&#39;, &#39;no&#39; );<br>	} else {<br>		$cache_key = &#34;$network_id:$option&#34;;<br><br>		// Make sure the option doesn&#39;t already exist.<br>		// We can check the &#39;notoptions&#39; cache before we ask for a DB query.<br>		$notoptions = wp_cache_get( $notoptions_key, &#39;site-options&#39; );<br><br>		if ( ! is_array( $notoptions ) || ! isset( $notoptions[ $option ] ) ) {<br>			if ( false !== get_network_option( $network_id, $option, false ) ) {<br>				return false;<br>			}<br>		}<br><br>		$value = sanitize_option( $option, $value );<br><br>		$serialized_value = maybe_serialize( $value );<br>		$result           = $wpdb-&gt;insert(<br>			$wpdb-&gt;sitemeta,<br>			array(<br>				&#39;site_id&#39;    =&gt; $network_id,<br>				&#39;meta_key&#39;   =&gt; $option,<br>				&#39;meta_value&#39; =&gt; $serialized_value,<br>			)<br>		);<br><br>		if ( ! $result ) {<br>			return false;<br>		}<br><br>		wp_cache_set( $cache_key, $value, &#39;site-options&#39; );<br><br>		// This option exists now.<br>		$notoptions = wp_cache_get( $notoptions_key, &#39;site-options&#39; ); // Yes, again... we need it to be fresh.<br><br>		if ( is_array( $notoptions ) &amp;&amp; isset( $notoptions[ $option ] ) ) {<br>			unset( $notoptions[ $option ] );<br>			wp_cache_set( $notoptions_key, $notoptions, &#39;site-options&#39; );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after a specific network option has been successfully added.<br>		 *<br>		 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>		 *<br>		 * @since 2.9.0 As &#34;add_site_option_{$key}&#34;<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param mixed  $value      Value of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#34;add_site_option_{$option}&#34;, $option, $value, $network_id );<br><br>		/**<br>		 * Fires after a network option has been successfully added.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param mixed  $value      Value of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#39;add_site_option&#39;, $option, $value, $network_id );<br><br>		return true;<br>	}<br><br>	return false;<br>}<br><br>/**<br> * Removes a network option by name.<br> *<br> * @since 4.4.0<br> *<br> * @see delete_option()<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param int    $network_id ID of the network. Can be null to default to the current network ID.<br> * @param string $option     Name of the option to delete. Expected to not be SQL-escaped.<br> * @return bool True if the option was deleted, false otherwise.<br> */<br>function delete_network_option( $network_id, $option ) {<br>	global $wpdb;<br><br>	if ( $network_id &amp;&amp; ! is_numeric( $network_id ) ) {<br>		return false;<br>	}<br><br>	$network_id = (int) $network_id;<br><br>	// Fallback to the current network if a network ID is not specified.<br>	if ( ! $network_id ) {<br>		$network_id = get_current_network_id();<br>	}<br><br>	/**<br>	 * Fires immediately before a specific network option is deleted.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.7.0 The `$network_id` parameter was added.<br>	 *<br>	 * @param string $option     Option name.<br>	 * @param int    $network_id ID of the network.<br>	 */<br>	do_action( &#34;pre_delete_site_option_{$option}&#34;, $option, $network_id );<br><br>	if ( ! is_multisite() ) {<br>		$result = delete_option( $option );<br>	} else {<br>		$row = $wpdb-&gt;get_row( $wpdb-&gt;prepare( &#34;SELECT meta_id FROM {$wpdb-&gt;sitemeta} WHERE meta_key = %s AND site_id = %d&#34;, $option, $network_id ) );<br>		if ( is_null( $row ) || ! $row-&gt;meta_id ) {<br>			return false;<br>		}<br>		$cache_key = &#34;$network_id:$option&#34;;<br>		wp_cache_delete( $cache_key, &#39;site-options&#39; );<br><br>		$result = $wpdb-&gt;delete(<br>			$wpdb-&gt;sitemeta,<br>			array(<br>				&#39;meta_key&#39; =&gt; $option,<br>				&#39;site_id&#39;  =&gt; $network_id,<br>			)<br>		);<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after a specific network option has been deleted.<br>		 *<br>		 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>		 *<br>		 * @since 2.9.0 As &#34;delete_site_option_{$key}&#34;<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#34;delete_site_option_{$option}&#34;, $option, $network_id );<br><br>		/**<br>		 * Fires after a network option has been deleted.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#39;delete_site_option&#39;, $option, $network_id );<br><br>		return true;<br>	}<br><br>	return false;<br>}<br><br>/**<br> * Updates the value of a network option that was already added.<br> *<br> * @since 4.4.0<br> *<br> * @see update_option()<br> *<br> * @global wpdb $wpdb WordPress database abstraction object.<br> *<br> * @param int    $network_id ID of the network. Can be null to default to the current network ID.<br> * @param string $option     Name of the option. Expected to not be SQL-escaped.<br> * @param mixed  $value      Option value. Expected to not be SQL-escaped.<br> * @return bool True if the value was updated, false otherwise.<br> */<br>function update_network_option( $network_id, $option, $value ) {<br>	global $wpdb;<br><br>	if ( $network_id &amp;&amp; ! is_numeric( $network_id ) ) {<br>		return false;<br>	}<br><br>	$network_id = (int) $network_id;<br><br>	// Fallback to the current network if a network ID is not specified.<br>	if ( ! $network_id ) {<br>		$network_id = get_current_network_id();<br>	}<br><br>	wp_protect_special_option( $option );<br><br>	$old_value = get_network_option( $network_id, $option, false );<br><br>	/**<br>	 * Filters a specific network option before its value is updated.<br>	 *<br>	 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>	 *<br>	 * @since 2.9.0 As &#39;pre_update_site_option_&#39; . $key<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$option` parameter was added.<br>	 * @since 4.7.0 The `$network_id` parameter was added.<br>	 *<br>	 * @param mixed  $value      New value of the network option.<br>	 * @param mixed  $old_value  Old value of the network option.<br>	 * @param string $option     Option name.<br>	 * @param int    $network_id ID of the network.<br>	 */<br>	$value = apply_filters( &#34;pre_update_site_option_{$option}&#34;, $value, $old_value, $option, $network_id );<br><br>	/*<br>	 * If the new and old values are the same, no need to update.<br>	 *<br>	 * Unserialized values will be adequate in most cases. If the unserialized<br>	 * data differs, the (maybe) serialized data is checked to avoid<br>	 * unnecessary database calls for otherwise identical object instances.<br>	 *<br>	 * See https://core.trac.wordpress.org/ticket/44956<br>	 */<br>	if ( $value === $old_value || maybe_serialize( $value ) === maybe_serialize( $old_value ) ) {<br>		return false;<br>	}<br><br>	if ( false === $old_value ) {<br>		return add_network_option( $network_id, $option, $value );<br>	}<br><br>	$notoptions_key = &#34;$network_id:notoptions&#34;;<br>	$notoptions     = wp_cache_get( $notoptions_key, &#39;site-options&#39; );<br><br>	if ( is_array( $notoptions ) &amp;&amp; isset( $notoptions[ $option ] ) ) {<br>		unset( $notoptions[ $option ] );<br>		wp_cache_set( $notoptions_key, $notoptions, &#39;site-options&#39; );<br>	}<br><br>	if ( ! is_multisite() ) {<br>		$result = update_option( $option, $value, &#39;no&#39; );<br>	} else {<br>		$value = sanitize_option( $option, $value );<br><br>		$serialized_value = maybe_serialize( $value );<br>		$result           = $wpdb-&gt;update(<br>			$wpdb-&gt;sitemeta,<br>			array( &#39;meta_value&#39; =&gt; $serialized_value ),<br>			array(<br>				&#39;site_id&#39;  =&gt; $network_id,<br>				&#39;meta_key&#39; =&gt; $option,<br>			)<br>		);<br><br>		if ( $result ) {<br>			$cache_key = &#34;$network_id:$option&#34;;<br>			wp_cache_set( $cache_key, $value, &#39;site-options&#39; );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after the value of a specific network option has been successfully updated.<br>		 *<br>		 * The dynamic portion of the hook name, `$option`, refers to the option name.<br>		 *<br>		 * @since 2.9.0 As &#34;update_site_option_{$key}&#34;<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param mixed  $value      Current value of the network option.<br>		 * @param mixed  $old_value  Old value of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#34;update_site_option_{$option}&#34;, $option, $value, $old_value, $network_id );<br><br>		/**<br>		 * Fires after the value of a network option has been successfully updated.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 4.7.0 The `$network_id` parameter was added.<br>		 *<br>		 * @param string $option     Name of the network option.<br>		 * @param mixed  $value      Current value of the network option.<br>		 * @param mixed  $old_value  Old value of the network option.<br>		 * @param int    $network_id ID of the network.<br>		 */<br>		do_action( &#39;update_site_option&#39;, $option, $value, $old_value, $network_id );<br><br>		return true;<br>	}<br><br>	return false;<br>}<br><br>/**<br> * Deletes a site transient.<br> *<br> * @since 2.9.0<br> *<br> * @param string $transient Transient name. Expected to not be SQL-escaped.<br> * @return bool True if the transient was deleted, false otherwise.<br> */<br>function delete_site_transient( $transient ) {<br><br>	/**<br>	 * Fires immediately before a specific site transient is deleted.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 3.0.0<br>	 *<br>	 * @param string $transient Transient name.<br>	 */<br>	do_action( &#34;delete_site_transient_{$transient}&#34;, $transient );<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$result = wp_cache_delete( $transient, &#39;site-transient&#39; );<br>	} else {<br>		$option_timeout = &#39;_site_transient_timeout_&#39; . $transient;<br>		$option         = &#39;_site_transient_&#39; . $transient;<br>		$result         = delete_site_option( $option );<br><br>		if ( $result ) {<br>			delete_site_option( $option_timeout );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after a transient is deleted.<br>		 *<br>		 * @since 3.0.0<br>		 *<br>		 * @param string $transient Deleted transient name.<br>		 */<br>		do_action( &#39;deleted_site_transient&#39;, $transient );<br>	}<br><br>	return $result;<br>}<br><br>/**<br> * Retrieves the value of a site transient.<br> *<br> * If the transient does not exist, does not have a value, or has expired,<br> * then the return value will be false.<br> *<br> * @since 2.9.0<br> *<br> * @see get_transient()<br> *<br> * @param string $transient Transient name. Expected to not be SQL-escaped.<br> * @return mixed Value of transient.<br> */<br>function get_site_transient( $transient ) {<br><br>	/**<br>	 * Filters the value of an existing site transient before it is retrieved.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * Returning a truthy value from the filter will effectively short-circuit retrieval<br>	 * and return the passed value instead.<br>	 *<br>	 * @since 2.9.0<br>	 * @since 4.4.0 The `$transient` parameter was added.<br>	 *<br>	 * @param mixed  $pre_site_transient The default value to return if the site transient does not exist.<br>	 *                                   Any value other than false will short-circuit the retrieval<br>	 *                                   of the transient, and return that value.<br>	 * @param string $transient          Transient name.<br>	 */<br>	$pre = apply_filters( &#34;pre_site_transient_{$transient}&#34;, false, $transient );<br><br>	if ( false !== $pre ) {<br>		return $pre;<br>	}<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$value = wp_cache_get( $transient, &#39;site-transient&#39; );<br>	} else {<br>		// Core transients that do not have a timeout. Listed here so querying timeouts can be avoided.<br>		$no_timeout       = array( &#39;update_core&#39;, &#39;update_plugins&#39;, &#39;update_themes&#39; );<br>		$transient_option = &#39;_site_transient_&#39; . $transient;<br>		if ( ! in_array( $transient, $no_timeout, true ) ) {<br>			$transient_timeout = &#39;_site_transient_timeout_&#39; . $transient;<br>			$timeout           = get_site_option( $transient_timeout );<br>			if ( false !== $timeout &amp;&amp; $timeout &lt; time() ) {<br>				delete_site_option( $transient_option );<br>				delete_site_option( $transient_timeout );<br>				$value = false;<br>			}<br>		}<br><br>		if ( ! isset( $value ) ) {<br>			$value = get_site_option( $transient_option );<br>		}<br>	}<br><br>	/**<br>	 * Filters the value of an existing site transient.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 2.9.0<br>	 * @since 4.4.0 The `$transient` parameter was added.<br>	 *<br>	 * @param mixed  $value     Value of site transient.<br>	 * @param string $transient Transient name.<br>	 */<br>	return apply_filters( &#34;site_transient_{$transient}&#34;, $value, $transient );<br>}<br><br>/**<br> * Sets/updates the value of a site transient.<br> *<br> * You do not need to serialize values. If the value needs to be serialized,<br> * then it will be serialized before it is set.<br> *<br> * @since 2.9.0<br> *<br> * @see set_transient()<br> *<br> * @param string $transient  Transient name. Expected to not be SQL-escaped. Must be<br> *                           167 characters or fewer in length.<br> * @param mixed  $value      Transient value. Expected to not be SQL-escaped.<br> * @param int    $expiration Optional. Time until expiration in seconds. Default 0 (no expiration).<br> * @return bool True if the value was set, false otherwise.<br> */<br>function set_site_transient( $transient, $value, $expiration = 0 ) {<br><br>	/**<br>	 * Filters the value of a specific site transient before it is set.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 3.0.0<br>	 * @since 4.4.0 The `$transient` parameter was added.<br>	 *<br>	 * @param mixed  $value     New value of site transient.<br>	 * @param string $transient Transient name.<br>	 */<br>	$value = apply_filters( &#34;pre_set_site_transient_{$transient}&#34;, $value, $transient );<br><br>	$expiration = (int) $expiration;<br><br>	/**<br>	 * Filters the expiration for a site transient before its value is set.<br>	 *<br>	 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>	 *<br>	 * @since 4.4.0<br>	 *<br>	 * @param int    $expiration Time until expiration in seconds. Use 0 for no expiration.<br>	 * @param mixed  $value      New value of site transient.<br>	 * @param string $transient  Transient name.<br>	 */<br>	$expiration = apply_filters( &#34;expiration_of_site_transient_{$transient}&#34;, $expiration, $value, $transient );<br><br>	if ( wp_using_ext_object_cache() || wp_installing() ) {<br>		$result = wp_cache_set( $transient, $value, &#39;site-transient&#39;, $expiration );<br>	} else {<br>		$transient_timeout = &#39;_site_transient_timeout_&#39; . $transient;<br>		$option            = &#39;_site_transient_&#39; . $transient;<br><br>		if ( false === get_site_option( $option ) ) {<br>			if ( $expiration ) {<br>				add_site_option( $transient_timeout, time() + $expiration );<br>			}<br>			$result = add_site_option( $option, $value );<br>		} else {<br>			if ( $expiration ) {<br>				update_site_option( $transient_timeout, time() + $expiration );<br>			}<br>			$result = update_site_option( $option, $value );<br>		}<br>	}<br><br>	if ( $result ) {<br><br>		/**<br>		 * Fires after the value for a specific site transient has been set.<br>		 *<br>		 * The dynamic portion of the hook name, `$transient`, refers to the transient name.<br>		 *<br>		 * @since 3.0.0<br>		 * @since 4.4.0 The `$transient` parameter was added<br>		 *<br>		 * @param mixed  $value      Site transient value.<br>		 * @param int    $expiration Time until expiration in seconds.<br>		 * @param string $transient  Transient name.<br>		 */<br>		do_action( &#34;set_site_transient_{$transient}&#34;, $value, $expiration, $transient );<br><br>		/**<br>		 * Fires after the value for a site transient has been set.<br>		 *<br>		 * @since 3.0.0<br>		 *<br>		 * @param string $transient  The name of the site transient.<br>		 * @param mixed  $value      Site transient value.<br>		 * @param int    $expiration Time until expiration in seconds.<br>		 */<br>		do_action( &#39;setted_site_transient&#39;, $transient, $value, $expiration );<br>	}<br><br>	return $result;<br>}<br><br>/**<br> * Registers default settings available in WordPress.<br> *<br> * The settings registered here are primarily useful for the REST API, so this<br> * does not encompass all settings available in WordPress.<br> *<br> * @since 4.7.0<br> *</span><ins class='diff-insert diff' style='background: #e6ffe6;'> @since 6.0.1 The `show_on_front`, `page_on_front`, and `page_for_posts` options were added.<br> *</ins><span class='diff'>/<br>function register_initial_settings() {<br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;blogname&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;name&#39; =&gt; &#39;title&#39;,<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Site title.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;blogdescription&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;name&#39; =&gt; &#39;description&#39;,<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Site tagline.&#39; ),<br>		)<br>	);<br><br>	if ( ! is_multisite() ) {<br>		register_setting(<br>			&#39;general&#39;,<br>			&#39;siteurl&#39;,<br>			array(<br>				&#39;show_in_rest&#39; =&gt; array(<br>					&#39;name&#39;   =&gt; &#39;url&#39;,<br>					&#39;schema&#39; =&gt; array(<br>						&#39;format&#39; =&gt; &#39;uri&#39;,<br>					),<br>				),<br>				&#39;type&#39;         =&gt; &#39;string&#39;,<br>				&#39;description&#39;  =&gt; __( &#39;Site URL.&#39; ),<br>			)<br>		);<br>	}<br><br>	if ( ! is_multisite() ) {<br>		register_setting(<br>			&#39;general&#39;,<br>			&#39;admin_email&#39;,<br>			array(<br>				&#39;show_in_rest&#39; =&gt; array(<br>					&#39;name&#39;   =&gt; &#39;email&#39;,<br>					&#39;schema&#39; =&gt; array(<br>						&#39;format&#39; =&gt; &#39;email&#39;,<br>					),<br>				),<br>				&#39;type&#39;         =&gt; &#39;string&#39;,<br>				&#39;description&#39;  =&gt; __( &#39;This address is used for admin purposes, like new user notification.&#39; ),<br>			)<br>		);<br>	}<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;timezone_string&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;name&#39; =&gt; &#39;timezone&#39;,<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;A city in the same timezone as you.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;date_format&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;A date format for all date strings.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;time_format&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;A time format for all time strings.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;start_of_week&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;integer&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;A day number of the week that the week should start on.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;general&#39;,<br>		&#39;WPLANG&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;name&#39; =&gt; &#39;language&#39;,<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;WordPress locale code.&#39; ),<br>			&#39;default&#39;      =&gt; &#39;en_US&#39;,<br>		)<br>	);<br><br>	register_setting(<br>		&#39;writing&#39;,<br>		&#39;use_smilies&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;boolean&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Convert emoticons like :-) and :-P to graphics on display.&#39; ),<br>			&#39;default&#39;      =&gt; true,<br>		)<br>	);<br><br>	register_setting(<br>		&#39;writing&#39;,<br>		&#39;default_category&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;integer&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Default post category.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;writing&#39;,<br>		&#39;default_post_format&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Default post format.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;reading&#39;,<br>		&#39;posts_per_page&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;integer&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Blog pages show at most.&#39; ),<br>			&#39;default&#39;      =&gt; 10</span><ins class='diff-insert diff' style='background: #e6ffe6;'>,<br>		)<br>	);<br><br>	register_setting(<br>		&#39;reading&#39;,<br>		&#39;show_on_front&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;What to show on the front page&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;reading&#39;,<br>		&#39;page_on_front&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;integer&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;The ID of the page that should be displayed on the front page&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;reading&#39;,<br>		&#39;page_for_posts&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; true,<br>			&#39;type&#39;         =&gt; &#39;integer&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;The ID of the page that should display the latest posts&#39; )</ins><span class='diff'>,<br>		)<br>	);<br><br>	register_setting(<br>		&#39;discussion&#39;,<br>		&#39;default_ping_status&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;schema&#39; =&gt; array(<br>					&#39;enum&#39; =&gt; array( &#39;open&#39;, &#39;closed&#39; ),<br>				),<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Allow link notifications from other blogs (pingbacks and trackbacks) on new articles.&#39; ),<br>		)<br>	);<br><br>	register_setting(<br>		&#39;discussion&#39;,<br>		&#39;default_comment_status&#39;,<br>		array(<br>			&#39;show_in_rest&#39; =&gt; array(<br>				&#39;schema&#39; =&gt; array(<br>					&#39;enum&#39; =&gt; array( &#39;open&#39;, &#39;closed&#39; ),<br>				),<br>			),<br>			&#39;type&#39;         =&gt; &#39;string&#39;,<br>			&#39;description&#39;  =&gt; __( &#39;Allow people to submit comments on new posts.&#39; ),<br>		)<br>	);<br>}<br><br>/**<br> * Registers a setting and its data.<br> *<br> * @since 2.7.0<br> * @since 3.0.0 The `misc` option group was deprecated.<br> * @since 3.5.0 The `privacy` option group was deprecated.<br> * @since 4.7.0 `$args` can be passed to set flags on the setting, similar to `register_meta()`.<br> * @since 5.5.0 `$new_whitelist_options` was renamed to `$new_allowed_options`.<br> *              Please consider writing more inclusive code.<br> *<br> * @global array $new_allowed_options<br> * @global array $wp_registered_settings<br> *<br> * @param string $option_group A settings group name. Should correspond to an allowed option key name.<br> *                             Default allowed option key names include &#39;general&#39;, &#39;discussion&#39;, &#39;media&#39;,<br> *                             &#39;reading&#39;, &#39;writing&#39;, and &#39;options&#39;.<br> * @param string $option_name The name of an option to sanitize and save.<br> * @param array  $args {<br> *     Data used to describe the setting when registered.<br> *<br> *     @type string     $type              The type of data associated with this setting.<br> *                                         Valid values are &#39;string&#39;, &#39;boolean&#39;, &#39;integer&#39;, &#39;number&#39;, &#39;array&#39;, and &#39;object&#39;.<br> *     @type string     $description       A description of the data attached to this setting.<br> *     @type callable   $sanitize_callback A callback function that sanitizes the option&#39;s value.<br> *     @type bool|array $show_in_rest      Whether data associated with this setting should be included in the REST API.<br> *                                         When registering complex settings, this argument may optionally be an<br> *                                         array with a &#39;schema&#39; key.<br> *     @type mixed      $default           Default value when calling `get_option()`.<br> * }<br> */<br>function register_setting( $option_group, $option_name, $args = array() ) {<br>	global $new_allowed_options, $wp_registered_settings;<br><br>	/*<br>	 * In 5.5.0, the `$new_whitelist_options` global variable was renamed to `$new_allowed_options`.<br>	 * Please consider writing more inclusive code.<br>	 */<br>	$GLOBALS[&#39;new_whitelist_options&#39;] = &amp;$new_allowed_options;<br><br>	$defaults = array(<br>		&#39;type&#39;              =&gt; &#39;string&#39;,<br>		&#39;group&#39;             =&gt; $option_group,<br>		&#39;description&#39;       =&gt; &#39;&#39;,<br>		&#39;sanitize_callback&#39; =&gt; null,<br>		&#39;show_in_rest&#39;      =&gt; false,<br>	);<br><br>	// Back-compat: old sanitize callback is added.<br>	if ( is_callable( $args ) ) {<br>		$args = array(<br>			&#39;sanitize_callback&#39; =&gt; $args,<br>		);<br>	}<br><br>	/**<br>	 * Filters the registration arguments when registering a setting.<br>	 *<br>	 * @since 4.7.0<br>	 *<br>	 * @param array  $args         Array of setting registration arguments.<br>	 * @param array  $defaults     Array of default arguments.<br>	 * @param string $option_group Setting group.<br>	 * @param string $option_name  Setting name.<br>	 */<br>	$args = apply_filters( &#39;register_setting_args&#39;, $args, $defaults, $option_group, $option_name );<br><br>	$args = wp_parse_args( $args, $defaults );<br><br>	// Require an item schema when registering settings with an array type.<br>	if ( false !== $args[&#39;show_in_rest&#39;] &amp;&amp; &#39;array&#39; === $args[&#39;type&#39;] &amp;&amp; ( ! is_array( $args[&#39;show_in_rest&#39;] ) || ! isset( $args[&#39;show_in_rest&#39;][&#39;schema&#39;][&#39;items&#39;] ) ) ) {<br>		_doing_it_wrong( __FUNCTION__, __( &#39;When registering an &#34;array&#34; setting to show in the REST API, you must specify the schema for each array item in &#34;show_in_rest.schema.items&#34;.&#39; ), &#39;5.4.0&#39; );<br>	}<br><br>	if ( ! is_array( $wp_registered_settings ) ) {<br>		$wp_registered_settings = array();<br>	}<br><br>	if ( &#39;misc&#39; === $option_group ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;3.0.0&#39;,<br>			sprintf(<br>				/* translators: %s: misc */<br>				__( &#39;The &#34;%s&#34; options group has been removed. Use another settings group.&#39; ),<br>				&#39;misc&#39;<br>			)<br>		);<br>		$option_group = &#39;general&#39;;<br>	}<br><br>	if ( &#39;privacy&#39; === $option_group ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;3.5.0&#39;,<br>			sprintf(<br>				/* translators: %s: privacy */<br>				__( &#39;The &#34;%s&#34; options group has been removed. Use another settings group.&#39; ),<br>				&#39;privacy&#39;<br>			)<br>		);<br>		$option_group = &#39;reading&#39;;<br>	}<br><br>	$new_allowed_options[ $option_group ][] = $option_name;<br><br>	if ( ! empty( $args[&#39;sanitize_callback&#39;] ) ) {<br>		add_filter( &#34;sanitize_option_{$option_name}&#34;, $args[&#39;sanitize_callback&#39;] );<br>	}<br>	if ( array_key_exists( &#39;default&#39;, $args ) ) {<br>		add_filter( &#34;default_option_{$option_name}&#34;, &#39;filter_default_option&#39;, 10, 3 );<br>	}<br><br>	/**<br>	 * Fires immediately before the setting is registered but after its filters are in place.<br>	 *<br>	 * @since 5.5.0<br>	 *<br>	 * @param string $option_group Setting group.<br>	 * @param string $option_name  Setting name.<br>	 * @param array  $args         Array of setting registration arguments.<br>	 */<br>	do_action( &#39;register_setting&#39;, $option_group, $option_name, $args );<br><br>	$wp_registered_settings[ $option_name ] = $args;<br>}<br><br>/**<br> * Unregisters a setting.<br> *<br> * @since 2.7.0<br> * @since 4.7.0 `$sanitize_callback` was deprecated. The callback from `register_setting()` is now used instead.<br> * @since 5.5.0 `$new_whitelist_options` was renamed to `$new_allowed_options`.<br> *              Please consider writing more inclusive code.<br> *<br> * @global array $new_allowed_options<br> * @global array $wp_registered_settings<br> *<br> * @param string   $option_group The settings group name used during registration.<br> * @param string   $option_name  The name of the option to unregister.<br> * @param callable $deprecated   Optional. Deprecated.<br> */<br>function unregister_setting( $option_group, $option_name, $deprecated = &#39;&#39; ) {<br>	global $new_allowed_options, $wp_registered_settings;<br><br>	/*<br>	 * In 5.5.0, the `$new_whitelist_options` global variable was renamed to `$new_allowed_options`.<br>	 * Please consider writing more inclusive code.<br>	 */<br>	$GLOBALS[&#39;new_whitelist_options&#39;] = &amp;$new_allowed_options;<br><br>	if ( &#39;misc&#39; === $option_group ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;3.0.0&#39;,<br>			sprintf(<br>				/* translators: %s: misc */<br>				__( &#39;The &#34;%s&#34; options group has been removed. Use another settings group.&#39; ),<br>				&#39;misc&#39;<br>			)<br>		);<br>		$option_group = &#39;general&#39;;<br>	}<br><br>	if ( &#39;privacy&#39; === $option_group ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;3.5.0&#39;,<br>			sprintf(<br>				/* translators: %s: privacy */<br>				__( &#39;The &#34;%s&#34; options group has been removed. Use another settings group.&#39; ),<br>				&#39;privacy&#39;<br>			)<br>		);<br>		$option_group = &#39;reading&#39;;<br>	}<br><br>	$pos = array_search( $option_name, (array) $new_allowed_options[ $option_group ], true );<br><br>	if ( false !== $pos ) {<br>		unset( $new_allowed_options[ $option_group ][ $pos ] );<br>	}<br><br>	if ( &#39;&#39; !== $deprecated ) {<br>		_deprecated_argument(<br>			__FUNCTION__,<br>			&#39;4.7.0&#39;,<br>			sprintf(<br>				/* translators: 1: $sanitize_callback, 2: register_setting() */<br>				__( &#39;%1$s is deprecated. The callback from %2$s is used instead.&#39; ),<br>				&#39;&lt;code&gt;$sanitize_callback&lt;/code&gt;&#39;,<br>				&#39;&lt;code&gt;register_setting()&lt;/code&gt;&#39;<br>			)<br>		);<br>		remove_filter( &#34;sanitize_option_{$option_name}&#34;, $deprecated );<br>	}<br><br>	if ( isset( $wp_registered_settings[ $option_name ] ) ) {<br>		// Remove the sanitize callback if one was set during registration.<br>		if ( ! empty( $wp_registered_settings[ $option_name ][&#39;sanitize_callback&#39;] ) ) {<br>			remove_filter( &#34;sanitize_option_{$option_name}&#34;, $wp_registered_settings[ $option_name ][&#39;sanitize_callback&#39;] );<br>		}<br><br>		// Remove the default filter if a default was provided during registration.<br>		if ( array_key_exists( &#39;default&#39;, $wp_registered_settings[ $option_name ] ) ) {<br>			remove_filter( &#34;default_option_{$option_name}&#34;, &#39;filter_default_option&#39;, 10 );<br>		}<br><br>		/**<br>		 * Fires immediately before the setting is unregistered and after its filters have been removed.<br>		 *<br>		 * @since 5.5.0<br>		 *<br>		 * @param string $option_group Setting group.<br>		 * @param string $option_name  Setting name.<br>		 */<br>		do_action( &#39;unregister_setting&#39;, $option_group, $option_name );<br><br>		unset( $wp_registered_settings[ $option_name ] );<br>	}<br>}<br><br>/**<br> * Retrieves an array of registered settings.<br> *<br> * @since 4.7.0<br> *<br> * @global array $wp_registered_settings<br> *<br> * @return array List of registered settings, keyed by option name.<br> */<br>function get_registered_settings() {<br>	global $wp_registered_settings;<br><br>	if ( ! is_array( $wp_registered_settings ) ) {<br>		return array();<br>	}<br><br>	return $wp_registered_settings;<br>}<br><br>/**<br> * Filters the default value for the option.<br> *<br> * For settings which register a default setting in `register_setting()`, this<br> * function is added as a filter to `default_option_{$option}`.<br> *<br> * @since 4.7.0<br> *<br> * @param mixed  $default        Existing default value to return.<br> * @param string $option         Option name.<br> * @param bool   $passed_default Was `get_option()` passed a default value?<br> * @return mixed Filtered default value.<br> */<br>function filter_default_option( $default, $option, $passed_default ) {<br>	if ( $passed_default ) {<br>		return $default;<br>	}<br><br>	$registered = get_registered_settings();<br>	if ( empty( $registered[ $option ] ) ) {<br>		return $default;<br>	}<br><br>	return $registered[ $option ][&#39;default&#39;];<br>}<br></span>